const fs = require("fs-extra");
const {
  ipcRenderer,
  remote
} = require("electron");
const {
  BrowserWindow,
  Menu
} = require("electron").remote;
window.this = remote.getCurrentWindow();
window.mimeList = []
window.getMimeType = function(ext) {
  console.log(window.mimeList.find(o => o.extension === ext), ext)
  if (window.mimeList.find(o => o.extension === ext) === undefined) {
    if (ext.indexOf("/") !== -1) return "inode/directory";
    else return "text/plain";
  } else return window.mimeList.find(o => o.extension === ext)["mime"]
}

window.onload = function() {
  $("*").mousedown(function() {
    if (remote.getCurrentWindow().id !== 3)
      if (remote.getCurrentWindow().id !== 4)
        if (remote.getCurrentWindow().id !== 5) {
          BrowserWindow.fromId(3).hide();
          BrowserWindow.fromId(4).hide();
          BrowserWindow.fromId(5).hide();

        }
  })
}

// File Clipboard API
window.fileClipboard = {}
window.fileClipboard.clipboard = remote.getGlobal("clipboards").file;
window.fileClipboard.add = function(path) {
  var oldcb = remote.getGlobal("clipboards").file;
  oldcb.push(path);
  remote.getGlobal("clipboards").file = oldcb;
}
window.fileClipboard.copyMode = "copy";
window.fileClipboard.clear = function() {
  remote.getGlobal("clipboards").file = [];
}
window.fileClipboard.flush = function(target) {
  var clipboard = remote.getGlobal("clipboards").file;
  clipboard.forEach(function(file) {
    fs.copySync(file, target + file.substring(file.lastIndexOf("/")));
    if (window.fileClipboard.copyMode === "cut") fs.removeSync(file);
  })
  window.fileClipboard.clear();
}
Object.defineProperty(window.fileClipboard, "isFilled", {
  get: function() {
    return !(remote.getGlobal("clipboards").file[0] === undefined);
  }
});
// } //

window.fileOpen = function(path) {
  var mime = window.getMimeType(path.substring(path.lastIndexOf(".") + 1));
  console.log(mime);
  fs.readFile("/atomos/etc/associations.json", "utf8", function(err, assocs) {
    assocs = $.parseJSON(assocs);

    console.log(assocs);
    assocs = assocs.find(o => o.mime == mime);
    console.log(assocs);
    if (assocs) window.new(assocs.app, {
      path: path
    });
    else window.new("aos-appchooserdialog", {
      path: path,
      mimeType: mime
    });
  })
}
window.new = function(app, args, electronOptions) {
  return $.getJSON("/atomos/etc/apps/" + app.replace("/", "-") + ".json", function(settings) {
    var defaultOptions = {
      width: settings.width || 400,
      height: settings.height || 300,
      minWidth: settings.minWidth || 100,
      minHeight: settings.minHeight || 100,
      resizable: (settings.resizable === undefined ? true : settings.resizable),
      minimizable: (settings.minimizable === undefined ? true : settings.minimizable),
      maximizable: (settings.maximizable === undefined ? true : settings.maximizable),
      closable: (settings.closable === undefined ? true : settings.closable),
      title: settings.name || "New Application",
      acceptFirstMouse: true,
      webPreferences: {
        preload: "/atomos/apps/preload.js",
        defaultEncoding: "utf-8"
      }
    };
    const {
      BrowserWindow
    } = require("electron").remote;
    Object.assign(defaultOptions, defaultOptions, settings, electronOptions);
    let win = new BrowserWindow(defaultOptions);
    require('electron').ipcRenderer.send("setArguments", {
      wid: win.id,
      arguments: args
    })
    win.setIcon = function(icon) {
      ipcRenderer.send("icon-change", {
        icon: icon,
        wid: win.id
      })
    };
    win.setIcon(settings.icon || "/atomos/icons/Application.png");
    win.setMenu(null);
    win.webContents.on("context-menu", function(event, params) {
      console.log(event, params);
      if (params.inputFieldType !== "none") {
        var cmenu = [{
          label: "Undo",
          accelerator: "CmdOrCtrl+Z",
          click() {
            win.webContents.send("return-menu", "__undo")
          },
          disabled: !params.editFlags.canUndo
        }, {
          label: "Redo",
          accelerator: "CmdOrCtrl+Shift+Z",
          click() {
            win.webContents.send("return-menu", "__redo")
          },
          disabled: !params.editFlags.canRedo
        }, {
          type: "separator"
        }, {
          label: "Cut",
          accelerator: "CmdOrCtrl+X",
          click() {
            win.webContents.send("return-menu", "__cut")
          },
          disabled: !params.editFlags.canCut
        }, {
          label: "Copy",
          accelerator: "CmdOrCtrl+C",
          click() {
            win.webContents.send("return-menu", "__copy")
          },
          disabled: !params.editFlags.canCopy
        }, {
          label: "Paste",
          accelerator: "CmdOrCtrl+V",
          click() {
            win.webContents.send("return-menu", "__paste")
          },
          disabled: !params.editFlags.canPaste
        }, {
          type: "separator"
        }, {
          label: "Select all",
          accelerator: "CmdOrCtrl+A",
          click() {
            win.webContents.send("return-menu", "__select all")
          },
          disabled: !params.editFlags.canSelectAll
        }];
        var menu = new Menu.buildFromTemplate(cmenu).popup(win)
      }
    })
    win.loadURL("file:///atomos/apps/" + app + "/index.html");
    win.show();
  })
}
fs.readFile("/etc/mime.types", "utf8", function(errno, mimeList) {
  var mimeArr = mimeList.split("\n");
  mimeArr.forEach(function(mime) {
    if (mime[0] != "#" && mime.trim() != "" && mime.indexOf("	") !== -1) {
      var m1 = mime.trim().split("	");
      m1 = m1.filter((n) => {
        return n != ""
      });
      var exts = m1[1].trim().split(" ");
      exts.forEach(function(ext) {
        window.mimeList.push({
          mime: m1[0].trim(),
          extension: ext
        });
      })
    }
  })
})
