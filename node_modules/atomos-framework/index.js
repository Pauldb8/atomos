
const {
  ipcRenderer,
  remote
} = require("electron");
document.addEventListener("DOMContentLoaded", function() {
  if(!$("link[href*='atomos.css']").length)
  document.body.innerHTML = '<link rel="stylesheet" href="/atomos/lib/atomos.css" />' + document.body.innerHTML;
})

const fs = require("fs-extra");
const {
  BrowserWindow,
  Menu
} = require("electron").remote;
window.$ = window.jQuery = require("jquery")
window.this = remote.getCurrentWindow();
window.mimeList = []
window.getMimeType = function(ext) {
  if (window.mimeList.find(o => o.extension === ext) === undefined) {
    if (ext.indexOf("/") !== -1) return "inode/directory";
    else return "text/plain";
  } else return window.mimeList.find(o => o.extension === ext)["mime"]
}

window.Tray = class {
  constructor(glyph, title = "", color = "#000") {
    this.glyph = glyph;
    this.title = title;
    this.color = color;
    this.onNotificationClick = function() {};
    this.onClick = function() {};
    this.onContextClick = function() {};

    return this;
  }

  changeColor(color) {
    this.color = color;
    remote.BrowserWindow.fromId(2).webContents.send("change-tray-color", {
      win: remote.getCurrentWindow().id,
      color: this.color
    });
  }
  off(event = "") {
    if (event === "") {
      this.onNotificationClick = function() {};
      this.onClick = function() {};
      this.onContextClick = function() {};
    } else switch (event) {
      case "notificationClick":
        this.onNotificationClick = function() {};
        break;
      case "click":
        this.onClick = function() {};
        break;
      case "contextClick":
        this.onContextClick = function() {};
        break;
    }
  }

  on(event, func) {
    switch (event.toLowerCase()) {
      case "notificationclick":
        this.onNotificationClick = func;
        break;
      case "click":
        this.onClick = func;
        break;
      case "contextclick":
        this.onContextClick = func;
        break;
    }

    return this;
  }

  show() {
    var proto = this;
    ipcRenderer.on('tray-click', function(event, arg) {
      proto.onClick();
    })
    ipcRenderer.on('tray-context-click', function(event, arg) {
      proto.onContextClick();
    })
    ipcRenderer.on('notification-click', function(event, arg) {
      proto.onNotificationClick();
    })
    remote.BrowserWindow.fromId(2).webContents.send("create-tray", {
      glyph: this.glyph,
      title: this.title,
      win: remote.getCurrentWindow().id,
      color: this.color
    });
    return this;
  }

  close() {
    remote.BrowserWindow.fromId(2).webContents.send("close-tray", {
      win: remote.getCurrentWindow().id,
    });
  }

  notify(options) {
    var defaultOptions = {
      html: "Nothing to show",
      title: "Notification",
      timeout: 10000,
      after: "REMOVE",
      dismissable: false,
      color: this.color,
      win: remote.getCurrentWindow().id
    }
    options = Object.assign({}, defaultOptions, options);
    remote.BrowserWindow.fromId(6).webContents.send("spawn-notification", options);

    return this;
  }
}

// File Clipboard API
window.fileClipboard = {}
window.fileClipboard.clipboard = remote.getGlobal("clipboards").file;
window.fileClipboard.add = function(path) {
  var oldcb = remote.getGlobal("clipboards").file;
  oldcb.push(path);
  remote.getGlobal("clipboards").file = oldcb;
}
window.fileClipboard.copyMode = "copy";
window.fileClipboard.clear = function() {
  remote.getGlobal("clipboards").file = [];
}
window.fileClipboard.flush = function(target) {
  var clipboard = remote.getGlobal("clipboards").file;
  clipboard.forEach(function(file) {
    fs.copySync(file, target + file.substring(file.lastIndexOf("/")));
    if (window.fileClipboard.copyMode === "cut") fs.removeSync(file);
  })
  window.fileClipboard.clear();
}
Object.defineProperty(window.fileClipboard, "isFilled", {
  get: function() {
    return !(remote.getGlobal("clipboards").file[0] === undefined);
  }
});
// } //

window.fileOpen = function(path) {
  var mime = window.getMimeType(path.substring(path.lastIndexOf(".") + 1));
  fs.readFile("/atomos/etc/associations.json", "utf8", function(err, assocs) {
    assocs = $.parseJSON(assocs);
    assocs = assocs.find(o => o.mime == mime);
    if (assocs) window.new(assocs.app, {
      path: path
    });
    else window.new("aos-appchooserdialog", {
      path: path,
      mimeType: mime
    });
  })
}
window.new = function(app, args, electronOptions) {
  return $.getJSON("/atomos/etc/apps/" + app.replace("/", "-") + ".json", function(settings) {
    var defaultOptions = {
      width: settings.width || 400,
      height: settings.height || 300,
      minWidth: settings.minWidth || 100,
      minHeight: settings.minHeight || 100,
      resizable: (settings.resizable === undefined ? true : settings.resizable),
      minimizable: (settings.minimizable === undefined ? true : settings.minimizable),
      maximizable: (settings.maximizable === undefined ? true : settings.maximizable),
      closable: (settings.closable === undefined ? true : settings.closable),
      title: settings.name || "New Application",
      show: false,
      acceptFirstMouse: true,
      webPreferences: {
        defaultEncoding: "utf-8"
      }
    };
    const {
      BrowserWindow
    } = require("electron").remote;
    Object.assign(defaultOptions, defaultOptions, settings, electronOptions);
    let win = new BrowserWindow(defaultOptions);
    require('electron').ipcRenderer.send("setArguments", {
      wid: win.id,
      arguments: args
    })
    win.setIcon = function(icon) {
      ipcRenderer.send("icon-change", {
        icon: icon,
        wid: win.id
      })
    };
    win.setIcon(settings.icon || "/atomos/icons/Application.png");
    win.setMenu(null);
    win.webContents.on("context-menu", function(event, params) {
      if (params.inputFieldType !== "none") {
        var cmenu = [{
          label: "Undo",
          accelerator: "CmdOrCtrl+Z",
          click() {
            win.webContents.send("return-menu", "__undo")
          },
          disabled: !params.editFlags.canUndo
        }, {
          label: "Redo",
          accelerator: "CmdOrCtrl+Shift+Z",
          click() {
            win.webContents.send("return-menu", "__redo")
          },
          disabled: !params.editFlags.canRedo
        }, {
          type: "separator"
        }, {
          label: "Cut",
          accelerator: "CmdOrCtrl+X",
          click() {
            win.webContents.send("return-menu", "__cut")
          },
          disabled: !params.editFlags.canCut
        }, {
          label: "Copy",
          accelerator: "CmdOrCtrl+C",
          click() {
            win.webContents.send("return-menu", "__copy")
          },
          disabled: !params.editFlags.canCopy
        }, {
          label: "Paste",
          accelerator: "CmdOrCtrl+V",
          click() {
            win.webContents.send("return-menu", "__paste")
          },
          disabled: !params.editFlags.canPaste
        }, {
          type: "separator"
        }, {
          label: "Select all",
          accelerator: "CmdOrCtrl+A",
          click() {
            win.webContents.send("return-menu", "__select all")
          },
          disabled: !params.editFlags.canSelectAll
        }];
        var menu = new Menu.buildFromTemplate(cmenu).popup(win)
      }
    })
    win.loadURL("file:///atomos/apps/" + app + "/index.html");
  })
}
fs.readFile("/etc/mime.types", "utf8", function(errno, mimeList) {
  var mimeArr = mimeList.split("\n");
  mimeArr.forEach(function(mime) {
    if (mime[0] != "#" && mime.trim() != "" && mime.indexOf("	") !== -1) {
      var m1 = mime.trim().split("	");
      m1 = m1.filter((n) => {
        return n != ""
      });
      var exts = m1[1].trim().split(" ");
      exts.forEach(function(ext) {
        window.mimeList.push({
          mime: m1[0].trim(),
          extension: ext
        });
      })
    }
  })
})

ipcRenderer.on("return-menu", function(event, action) {
  switch (action) {
    case "__undo":
      remote.getCurrentWebContents().undo();
      break;
    case "__redo":
      remote.getCurrentWebContents().redo();
      break;
    case "__copy":
      remote.getCurrentWebContents().copy();
      break;
    case "__cut":
      remote.getCurrentWebContents().cut();
      break;
    case "__paste":
      remote.getCurrentWebContents().paste();
      break;
    case "__select all":
      remote.getCurrentWebContents().selectAll();
      break;
  }
})
$(window).keyup(function(e) {
  if (e.shiftKey && e.ctrlKey && e.keyCode == 73) require("electron").remote.getCurrentWindow().toggleDevTools();
  if (e.ctrlKey && e.keyCode == 82) location.reload();
  if (e.keyCode == 122) require("electron").remote.getCurrentWindow().setFullScreen(!require("electron").remote.getCurrentWindow().isFullScreen())
  if ((event.key == "+" || event.key == "=") && e.ctrlKey) {
    require("electron").remote.getCurrentWebContents().getZoomFactor(function(zoomFactor) {
      zoomFactor += 0.1;
      require("electron").remote.getCurrentWebContents().setZoomFactor(zoomFactor);
    });
  }
  if (event.key == "-" && e.ctrlKey) {
    require("electron").remote.getCurrentWebContents().getZoomFactor(function(zoomFactor) {
      zoomFactor -= 0.1;
      require("electron").remote.getCurrentWebContents().setZoomFactor(zoomFactor);
    });
  }
})
window.addEventListener("load", function() {
  if(location.pathname.includes("apps") && window.this.isFullScreenable()) remote.getCurrentWindow().show();
})
module.exports.arguments = ipcRenderer.sendSync("getArguments", remote.getCurrentWindow().id);
console.log(module.exports.arguments)
