/*
 * Umm, I tell you right now, I am bad in writing comment.s
 * I will try to improve my open-source skills, but it will require some time.
 * Want to read this bulls**t? Go on, but do not blame me, I know...
 */
const {
	ipcRenderer,
	remote
} = require("electron");
const fs = require("fs-extra");
const {
	BrowserWindow,
	Menu,
	app,
	screen,
	session
} = remote;
const proc = require("child_process");
const win = remote.getCurrentWindow();
const wc = remote.getCurrentWebContents();
const path = require("path");
let systemRegistry = session.fromPartition("persist:registry").cookies;
const defaultOptions = {
	width: 400,
	height: 300,
	minWidth: 100,
	minHeight: 100,
	resizable: true,
	minimizable: true,
	maximizable: true,
	closable: true,
	title: "New Application",
	show: false,
	showOnLoad: true,
	icon: "$SYSTEM_ROOT/icons/Application.png",
	skipTaskbar: false
};

const cmenu = [{
		role: 'undo',
		accelerator: "CmdOrCtrl+Z"
	},
	{
		accelerator: "CmdOrCtrl+Shift+Z",
		role: 'redo'
	},
	{
		type: "separator"
	},
	{
		accelerator: "CmdOrCtrl+X",
		role: 'cut'
	},
	{
		accelerator: "CmdOrCtrl+C",
		role: 'copy'
	},
	{
		accelerator: "CmdOrCtrl+V",
		role: 'paste'
	},
	{
		type: "separator"
	},
	{
		accelerator: "CmdOrCtrl+A",
		role: 'selectall'
	}
];
/*
 * wsk is a window-state-manager in AtomOS
 * It saves and reuses saved window size and position to make apps more native.
 */

const wsk = remote.getGlobal("wsk");
if (!document.querySelector("link[href*='atomos.css']") && wc)
	document.body.innerHTML =
	'<link rel="stylesheet" href="file:///' + app.getAppPath() +
	'/lib/atomos.css" />' + document.body.innerHTML;

module.exports.Notification = class {
	/*
	 * This thingy sends an IPC signal to taskbar notification widget, so you need it turned on to
	 * receive notifications
	 */
	constructor(options = {}) {
		if (options instanceof Error) {
			options.title = options.name;
			options.body = options.message;
		}
		options.icon = wc.browserWindowOptions.icon; // Some apps still use a custom notification icon. I will not admit this.
		let nSettings = fs.readJsonSync(app.getPath("appData") + "/notify.json")[
			module.exports.app.name];
		if (!nSettings[1])
			options.mute = true;
		if (!nSettings[0])
			options.hidePopup = true;

		BrowserWindow.getAllWindows().forEach(function(win) {
			if (win.getURL().indexOf("notification") !== -1)
				win.webContents.send("new-notification", options);
		});
	}
};
module.exports.Menu = class {
	constructor(template = []) {
		this.menu = template;
		this.eMenu = Menu.buildFromTemplate(this.menu);
	}
	static buildFromTemplate(template) {
		return new this(template);
	}
	get items() {
		return this.menu;
	}
	popup(brWin = win, options = {
		//x: screen.getCursorScreenPoint().x,
		//y: screen.getCursorScreenPoint().y,
		async: true
	}) {
		this.eMenu.popup(brWin, options);
	}
	closePopup(brWin = win) {
		this.eMenu.closePopup(brWin);
	}
};
module.exports.Tray = class {
	/*
	 * This one creates trays and notifications(removed) in the taskbar.
	 * Class may become deprecated and removed soon, but it is a subject to be thought of.
	 */
	constructor(glyph, title = "", color = "#000") {
		this.glyph = glyph;
		this.title = title;
		this.color = color;
		this.onClick = function() {};
		this.onContextClick = function() {};

		return this;
	}

	changeColor(color) {
		this.color = color;
		remote.BrowserWindow.fromId(remote.getGlobal("gui").taskbar).webContents.send(
			"change-tray-color", {
				win: win.id,
				color: this.color
			});
	}

	off(event = "") {
		if (event === "") {
			this.onClick = function() {};
			this.onContextClick = function() {};
		} else switch (event) {
			case "click":
				this.onClick = function() {};
				break;
			case "contextClick":
				this.onContextClick = function() {};
				break;
		}
	}

	on(event, func) {
		switch (event.toLowerCase()) {
			case "click":
				this.onClick = func;
				break;
			case "contextclick":
				this.onContextClick = func;
				break;
		}
		return this;
	}

	show() {
		var proto = this;
		ipcRenderer.on('tray-click', function(event, arg) {
			proto.onClick();
		});
		ipcRenderer.on('tray-context-click', function(event, arg) {
			proto.onContextClick();
		});
		remote.BrowserWindow.fromId(remote.getGlobal("gui").taskbar).webContents.send(
			"create-tray", {
				glyph: this.glyph,
				title: this.title,
				win: win.id,
				color: this.color
			});
		return this;
	}

	close() {
		remote.BrowserWindow.fromId(remote.getGlobal("gui").taskbar).webContents.send(
			"close-tray", {
				win: win.id,
			});
	}
};
module.exports.iconDB = {
	retrieveIconURL: function(iconID) {
		let iconPath = path.join(app.getAppPath(), "icons", iconID + ".png");
		if (fs.existsSync(iconPath))
			return "file://" + iconPath;
		else {
			var url = "https://png.icons8.com/color/96/000000/" + iconID.split(
				/(?=[A-Z])/).join('_').toLowerCase() + ".png";
			var file = fs.createWriteStream(iconPath);
			var request = require('https').get(url, function(response) {
				response.pipe(file);
				file.on('finish', function() {
					file.close(cb);
				});
			});
			return url;
		}
	}
};
module.exports.app = {
	window: win,
	webContents: wc,
	relaunch: function() {
		module.exports.app.launch(module.exports.app.name).then(window.close);
	},
	getPath: function(path) {
		if (path === "os")
			return app.getAppPath();
		else return app.getPath(path);
	},
	log: function(...args) {
		if (win.getParentWindow())
			win.getParentWindow().webContents.send("stdout", args.toString())
	},
	options: wc.browserWindowOptions,
	arguments: (wc.browserWindowOptions ? wc.browserWindowOptions.arguments || {} :
		{}),
	launchFromHTML: function(html, eOptions) {
		let win = new BrowserWindow(eOptions);
		if (remote.getGlobal("process").argv.indexOf("--debug-apps") !== -1) win.toggleDevTools();
		else win.setMenu(null);
		win.webContents.on("context-menu", function(event, params) {
			if (params.isEditable)
				new Menu.buildFromTemplate(cmenu).popup(win);
		});
		win.loadURL('data:text/html;charset=UTF-8,' + encodeURIComponent(html));
		return win;
	},
	launch: function(prog, args, electronOptions) {
		console.log(preferences.uiScaling);
		return new Promise(function(resolve, reject) {
			/*
			 * Finds if the requested app has a generic name
			 * It gets a defaultApps.json file and tries to associate given app name to a generic one, then
			 * changes app name so it would start the default app, assigned to it
			 */
			let dApps = preferences.defaultApplications;
			if (dApps[prog])
				prog = dApps[prog].app;
			fs.readJson(path.join(app.getAppPath(), "apps", prog, "/app.json"))
				.then(function(settings) {
					settings = Object.assign({}, defaultOptions, settings,
						electronOptions, {
							arguments: args
						});
					settings.icon = settings.icon
						.replace("$SYSTEM_ROOT", app.getAppPath())
						.replace("$APP_ROOT", path.join(app.getAppPath(), "apps", prog));
					settings.width = Math.ceil(settings.width * preferences.uiScaling);
					settings.height = Math.ceil(settings.height * preferences.uiScaling);
					settings.minHeight = Math.ceil(settings.minHeight * preferences.uiScaling);
					settings.maxHeight = Math.ceil(settings.maxHeight * preferences.uiScaling);
					settings.minWidth = Math.ceil(settings.minWidth * preferences.uiScaling);
					settings.maxWidth = Math.ceil(settings.maxWidth * preferences.uiScaling);
					let winState = new wsk(prog, {
						defaultWidth: settings.width,
						defaultHeight: settings.height,
					});
					let {
						width,
						height,
						x,
						y
					} = winState;
					Object.assign(settings, {
						width,
						height,
						x,
						y
					});
					let win = new BrowserWindow(settings);
					if (winState.maximized) win.maximize();
					if (remote.getGlobal("process").argv.indexOf("--debug-apps") !== -1)
						win.toggleDevTools();
					if (typeof args === "string")
						if (args.indexOf("--debug") !== -1) win.toggleDevTools();
					win.setMenu(null);
					win.on('close', () => {
						console.log(win);
						winState.saveState(win);
					});
					win.webContents.on("context-menu", function(event, params) {
						if (params.isEditable)
							new Menu.buildFromTemplate(cmenu).popup(win);
					});
					win.loadURL("file:///" + app.getAppPath() + "/apps/" + prog +
						"/index.html");
					resolve(win.id);
				})
				.catch(function(e) {
					new Notification({
						title: "App is not installed",
						body: "App failed to load: " + e
					});
				});
		});
	},
	name: path.join(path.normalize(win.getURL().substring(7)).replace(path.join(
		app.getAppPath(), "apps"), ""), "..").substring(1),
	isDefault: function(genericName) {
		return preferences.defaultApplications[genericName].app === module.exports.app
			.name;
	},
	setDefault: function(genericName) {
		if (preferences.defaultApplications[genericName])
			preferences.defaultApplications[genericName].app = module.exports.app.name;
	},
	fileOpen: function(url) {
		// Fetches associations.json file and compares file extenstion with associated and opens
		// or the associated app or App Chooser dialog
		var extension = path.extname(url).substring(1).toLowerCase().trim();
		let assocs = preferences.appAssociations.reverse().find(o => o.extension ==
			extension);
		if (assocs)
			module.exports.app.launch(assocs.app, {
				path: url
			});
		else
			module.exports.app.launch("aos-appchooserdialog", {
				path: url,
				extension: extension
			});
	}
};

module.exports.registry = {
	on: function(event, callback) {
		if (event === "changed") {
			systemRegistry.on(event, function(ev, cookie, c, d) {
				if (cookie.domain === "atomos.registry" && [module.exports.app.name,
						"system"
					].includes(cookie.name))
					callback(cookie, c, d);
			});
		}
	},
	off: systemRegistry.off,
	set: function(registryItem = {}, isSystem = false) {
		return new Promise((resolve = console.log, reject = console.error) => {
			this.get(isSystem).then(function(rItem) {
				console.log(rItem, registryItem);
				registryItem = Object.assign({}, rItem, registryItem);
				systemRegistry.set({
					url: "http://atomos.registry/",
					name: (isSystem === true ? "system" : (typeof isSystem ===
						"string" ? isSystem : module.exports.app.name)),
					domain: "atomos.registry",
					value: JSON.stringify(registryItem),
					expirationDate: Date.now() + 31540000
				}, (e) => {
					if (e) reject(e);
					else resolve();
				})
			}, isSystem).catch(console.error);
		});
	},
	get: function(system = false) {
		return new Promise((resolve = console.log, reject = console.error) => {
			systemRegistry.get({
				domain: "atomos.registry",
				url: "http://atomos.registry/",
				name: (system === true ? "system" : (typeof system === "string" ?
					system : module.exports.app.name))
			}, function(e, rItem = []) {
				if (e) reject(e);
				else resolve((!rItem.length ? {} : JSON.parse(rItem[0].value)))
			})
		})
	},
	remove: function(app = module.exports.app.name) {
		return new Promise((resolve = console.log, reject = console.error) => {
			systemRegistry.remove("http://atomos.registry", app, (e) => {
				if (e) reject(e);
				else resolve()
			});
		});
	}
}
let preferences;
module.exports.registry.get(true).then((s) => {
	preferences = new Proxy(s, {
		set(t, p, v) {
			if (p === "uiScaling")
				wc.setZoomFactor(v);
			t[p] = v;
			module.exports.registry.set(preferences, true).then(() => {})
			return true;
		}
	});

});
module.exports.registry.on("changed", function(cook) {
	if (cook.name === "system")
		preferences = JSON.parse(cook.value);
})

window.addEventListener("keyup", function(e) {
	document.addEventListener('dragover', event => event.preventDefault())
	document.addEventListener('drop', event => event.preventDefault())
	if (e.shiftKey && e.ctrlKey && e.keyCode == 73) win.toggleDevTools();
	if ((e.altKey && e.key === "Shift") || (e.shiftKey && e.key === "Meta")) {
		let layouts = fs.readJsonSync(app.getPath("appData") + "/kblayouts.json");
		let cLayout = proc.execSync("setxkbmap -query").toString();
		cLayout = cLayout.substring(cLayout.lastIndexOf("layout:") + 8).trim();
		proc.execSync("setxkbmap " + layouts[(layouts.indexOf(cLayout) + 1 >=
			layouts.length ? 0 : layouts.indexOf(cLayout) + 1)]);
		remote.BrowserWindow.fromId(remote.getGlobal("gui").taskbar).webContents.send(
			"changeLocale");
	}
	if (e.ctrlKey && e.keyCode == 82) location.reload();
	if (e.keyCode == 122) win.setFullScreen(!win.isFullScreen());
	if ((event.key == "+" || event.key == "=") && e.ctrlKey) {
		wc.getZoomFactor(function(zoomFactor) {
			zoomFactor += 0.1;
			wc.setZoomFactor(
				zoomFactor);
		});
	}
	if (event.key == "-" && e.ctrlKey) {
		wc.getZoomFactor(function(zoomFactor) {
			zoomFactor -= 0.1;
			wc.setZoomFactor(
				zoomFactor);
		});
	}
	if (event.key == "AudioVolumeUp") proc.exec(
		"amixer -D pulse sset Master 2%+");
	if (event.key == "AudioVolumeDown") proc.exec(
		"amixer -D pulse sset Master 2%-");
	if (event.key == "AudioVolumeMute") proc.exec(
		"amixer -D pulse set Master toggle");
	if (event.key == "BrowserHome") remote.BrowserWindow.getAllWindows().forEach(
		function(win) {
			if (win.id > 3) win.hide()
		})
	if (event.key == "LaunchMail") window.new("browser")
	if (event.key == "BrowserSearch") window.new("browser", {
		url: "https://google.com"
	})
	if (event.key == "LaunchApplication2") window.new("aos-calculator")
	if (event.key == "MediaTrackPrevious") {
		remote.BrowserWindow.getAllWindows().forEach(function(win2) {
			win2.webContents.send("changeTrack", {
				offset: -1
			})
		})
	}
	if (event.key == "MediaTrackNext") {
		remote.BrowserWindow.getAllWindows().forEach(function(win2) {
			win2.webContents.send("changeTrack", {
				offset: 1
			})
		})
	}
	if (event.key == "F13") window.new("musicplayer");
	if (event.key == "MediaPlayPause") {
		remote.BrowserWindow.getAllWindows().forEach(function(win2) {
			win2.webContents.send("changeTrack", {
				action: "toggle"
			});
		});
	}
});

window.addEventListener("load", function() {
	// showOnLoad option in the reality
	if (wc.browserWindowOptions)
		if (location.pathname.includes("apps") && wc.browserWindowOptions.showOnLoad) {
			document.body.style.opacity = 0;

			setTimeout(() => {
				win.show();
				document.body.style.opacity = 1;
			}, 100);

		}
	wc.setZoomFactor(preferences.uiScaling)
});